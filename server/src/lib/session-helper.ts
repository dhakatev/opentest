import * as _ from 'underscore';
import * as buildInfo from './build-info';
import * as configLoader from '../lib/config-loader';
import * as constants from '../lib/constants';
import * as dbManager from '../lib/db-manager';
import * as helpers from '../lib/helpers';
import * as logManager from '../lib/log-manager';
import * as  moment from 'moment';
import * as path from 'path';
import { ScriptEngine } from '../lib/script-engine';
import * as sessionHelper from '../lib/session-helper';
import * as testRepo from '../lib/test-repo';
import {
    ActorSessionState,
    ActorSessionTestState,
    SessionTestActor,
    SubtestContext,
    TestInfo,
    TestSessionProperties,
    TestContext,
    TestSessionInfo,
    TestSegmentInfo
} from './types';
import * as util from 'util';

let cleanupIntervalId;

async function cleanupSessions() {
    const db = dbManager.getDb();
    const sessions = await db.getSessions();
    const now = Date.now();
    const config = configLoader.getConfig();

    for (let session of sessions) {
        if (session.status === constants.testSessionStatus.ACQUIRING_ACTORS) {
            // Cancel session if it stays in ACQUIRING_ACTORS status for too long
            if (session.timeCreated &&
                config.acquireActorsTimeoutSec !== 0 &&
                now - session.timeCreated > config.acquireActorsTimeoutSec * 1000) {

                await cancelSession(session);
                logManager.getSessionLog(session.id).info(helpers.format(
                    'Cancelling session {0} because we were unable to acquire the necessary test actors in {1} seconds',
                    session.id,
                    config.acquireActorsTimeoutSec
                ));
            }
        } else if (session.status === constants.testSessionStatus.STARTED) {
            // Cancel session if the test actors don't report any activity for too long
            if (session.lastActivity &&
                config.noActivityTimeoutSec !== 0 &&
                now - session.lastActivity > config.noActivityTimeoutSec * 1000) {

                await cancelSession(session);
                logManager.getSessionLog(session.id).info(helpers.format(
                    'Cancelling session {0} because there was no activity for {1} seconds',
                    session.id,
                    config.noActivityTimeoutSec
                ));
            }
        }
    }
}

export async function cancelSession(testSession: TestSessionInfo) {
    const db = dbManager.getDb();
    const now = Date.now();

    // Free test actors
    try {
        let actors = await db.getActorsBySession(testSession.id);
        await Promise.all(actors.map(function (actor) {
            return db.updateActor(actor.id, { testSessionId: null });
        }));
    } catch (err) { }

    { // Mark test session and its pending tests as cancelled
        // Mark incomplete tests as cancelled
        var updatedTests = testSession.tests;
        for (let sessionTest of updatedTests) {
            if (sessionTest.status !== constants.testStatus.COMPLETED) {
                sessionTest.result = constants.testResult.CANCELLED;
                sessionTest.status = constants.testStatus.COMPLETED;
            }
        }

        // Update the test session object's properties
        testSession.result = constants.testSessionResult.CANCELLED;
        testSession.status = constants.testSessionStatus.COMPLETED;
        testSession.tests = updatedTests;
        testSession.timeCompleted = now;

        // Write the changes to the DB
        await db.updateSession(testSession.id, {
            result: testSession.result,
            status: testSession.status,
            tests: testSession.tests,
            timeCompleted: testSession.timeCompleted
        });
    }
}

export async function cancelSessionById(sessionId: number) {
    const db = dbManager.getDb();
    const testSession = await db.getSession(sessionId);
    await cancelSession(testSession);
}

/** Perform the various cleanup and finalization activities
 * necessary at the end of a test session. */
export async function completeSession(testSession: TestSessionInfo, sessionResult?) {
    const db = dbManager.getDb();
    sessionResult = sessionResult || constants.testSessionResult.CANCELLED;
    const now = Date.now();

    // Free test actors
    try {
        let actors = await db.getActorsBySession(testSession.id);
        await Promise.all(actors.map(function (actor) {
            return db.updateActor(actor.id, { testSessionId: null });
        }));
    } catch (err) { }

    { // Mark test session as complete and its not completed tests as cancelled
        // Mark incomplete tests as cancelled
        var updatedTests = testSession.tests;
        for (let sessionTest of updatedTests) {
            if (sessionTest.status !== constants.testStatus.COMPLETED) {
                sessionTest.result = constants.testResult.CANCELLED;
                sessionTest.status = constants.testStatus.COMPLETED;
            }
        }

        // Update the test session object's properties
        testSession.result = sessionResult;
        testSession.status = constants.testSessionStatus.COMPLETED;
        testSession.tests = updatedTests;
        testSession.timeCompleted = now;

        // Write the changes to the DB
        await db.updateSession(testSession.id, {
            result: testSession.result,
            status: testSession.status,
            tests: testSession.tests,
            timeCompleted: testSession.timeCompleted
        });
    }
}

/** Create a test session according to the specified session properties object */
export async function createSession(template: TestSessionProperties): Promise<number> {
    template.maxIterations = template.maxIterations || 1;
    template.sessionLabel = template.sessionLabel || Math.round(Date.now() / 1000).toString();

    return new Promise<number>(async function (resolve, reject) {
        const db = dbManager.getDb();

        // Identify an available session ID
        let sessionId = Math.round(moment().valueOf() / 1000);
        while (await db.getSession(sessionId) != null) {
            ++sessionId;
        }

        // Create session logger
        const log = logManager.getSessionLog(sessionId);

        log.debug(helpers.format("Sync server version: {0} {1} {2}",
            buildInfo.version,
            buildInfo.buildDate,
            buildInfo.commitSha));

        try {
            const testInfos = testRepo.getTestInfos(template.tests);
            if (testInfos.length === 0) {
                throw new Error(helpers.format(
                    "Session template contained no valid test names. The session template was: {0}",
                    JSON.stringify(template)));
            }

            let rawActors = [];
            const sessionTests: TestContext[] = [];
            const config = configLoader.getConfig();

            for (const testInfo of testInfos) {
                // Read test info from local repo
                const localTestInfo = testRepo.allTestInfos.find((t) => {
                    return t.name === testInfo.name && t.path === testInfo.path
                });

                addTestToSession(sessionTests, testInfo);

                function addTestToSession(
                    sessionTests, testInfo: TestInfo) {

                    rawActors = rawActors.concat(testInfo.actors);

                    const sessionTest: TestContext = {
                        actions: [],
                        currentIteration: 1,
                        currentSegmentIndex: 0,
                        isDataDriven: testInfo.dataDriven,
                        name: testInfo.name,
                        path: testInfo.path,
                        result: constants.testResult.PENDING,
                        status: constants.testStatus.PENDING,
                        segments: []
                    };

                    if (sessionTest.isDataDriven) {
                        sessionTest.currentDataRecordIndex = 0;
                    }

                    const maxSegmentIndex = Math.max.apply(null, testInfo.segments);

                    for (let segmentIndex = 0; segmentIndex <= maxSegmentIndex; ++segmentIndex) {
                        sessionTest.segments.push({
                            index: segmentIndex,
                            result: constants.segmentResult.PENDING,
                            status: constants.segmentStatus.PENDING
                        });
                    }

                    sessionTests.push(sessionTest);
                }
            }

            const requiredActors = _.union(rawActors).sort();
            const actorsInfo = requiredActors.map(function (a) {
                return { actorType: a, actorTags: template.actorTags, acquired: false };
            });

            const acquireActorsTimeout = config.acquireActorsTimeoutSec * 1000;
            const startAcquireTimeout = 1000;

            await db.insertSession(sessionId, template.sessionLabel || sessionId.toString());
            await db.updateSession(sessionId, {
                actorTags: template.actorTags,
                environment: (template.environment || '').trim(),
                maxIterations: template.maxIterations,
                tests: sessionTests
            });

            const startAcquireActorsTime = Date.now();
            const sessionActors = {};

            const tagsSuffix = template.actorTags && template.actorTags.length ?
                " [" + template.actorTags.join(', ') + "]" :
                "";
            log.info(helpers.format('Acquiring actors for session {0}: {1}{2}',
                sessionId,
                requiredActors.join(', '),
                tagsSuffix));
            await acquireActors();

            resolve(sessionId);

            async function acquireActors() {
                //TODO: Check that the test session is not cancelled. If it is, free all acquired actors and return.
                const session = await db.getSession(sessionId);

                if (!session || session.status === constants.testSessionStatus.COMPLETED) {
                    return;
                }

                try {
                    // Identify available actors to run this test session
                    for (let a of actorsInfo) {
                        if (!a.acquired) {
                            let testActor = _.find(
                                await db.getActorsByTypeAndTags(a.actorType, a.actorTags),
                                (actor) => !actor.testSessionId);

                            if (testActor) {
                                await db.updateActor(testActor.id, { testSessionId: sessionId });

                                // Make sure the update to the database happened and the actor is now
                                // acquired by this session. It could be that a different session got
                                // to it before the call to updateActor finished.
                                testActor = await db.getActor(testActor.id);
                                if (testActor && testActor.testSessionId === sessionId) {
                                    const sessionActor: SessionTestActor = {
                                        ...testActor,
                                        tests: []
                                    };
                                    sessionActors[sessionActor.id] = sessionActor;
                                    a.acquired = true;
                                }
                            }
                        }
                    }

                    const allActorsAcquired = actorsInfo.filter(function (a) { return !a.acquired; })[0] == undefined;
                    if (allActorsAcquired) {
                        await startTestSession();
                    } else {
                        if (Date.now() - startAcquireActorsTime < acquireActorsTimeout) {
                            setTimeout(acquireActors, startAcquireTimeout);
                        }
                    }
                } catch (err) {
                    console.error(err, err.stack);
                }
            }

            async function cancelTestSession(sessionId) {
                await db.updateSession(sessionId, {
                    actors: sessionActors,
                    result: constants.testSessionResult.CANCELLED,
                    status: constants.testSessionStatus.COMPLETED,
                    timeCompleted: Date.now()
                });
            }

            async function startTestSession() {
                log.info(helpers.format('Session {0} with label "{1}" started at {2} UTC',
                    sessionId,
                    template.sessionLabel,
                    moment().utc().format('YYYY-MM-DD HH:mm:ss')));

                await db.updateSession(sessionId, {
                    actors: sessionActors,
                    status: constants.testSessionStatus.STARTED
                });
            }
        } catch (err) {
            log.error(JSON.stringify(err));
            reject(err);
        }
    });
}

/** Increments the session iteration number and resets session state to
 * prepare for running the next iteration */
function incrementIteration(testSession: TestSessionInfo) {
    // Only continue if there's at least one failed test
    let firstFailedTestIndex = testSession.tests.findIndex((t) => t.result === constants.testResult.FAILED);
    if (firstFailedTestIndex === -1) { return; }

    ++testSession.currentIteration;

    // Reset data for failed tests, both for session and for the session actors
    for (let testIndex = 0; testIndex < testSession.tests.length; ++testIndex) {
        let test = testSession.tests[testIndex];

        if (test.result === constants.testResult.FAILED) {
            resetTestStatus(testSession, testIndex);
            test.currentIteration = testSession.currentIteration;
        }
    }

    testSession.currentTestIndex = firstFailedTestIndex;
    testSession.currentSegmentIndex = 0;
    testSession.currentDataRecordIndex = 0;
}

/** Iterates through all the test actors, collects the status and result of the
 * current test segment for each actor and computes an aggregate TestSegmentInfo object. */
function computeCurrentTestSegmentInfo(testSession: TestSessionInfo): TestSegmentInfo {
    let currentSegmentPassed = true;
    let currentSegmentWasCompleted = true;
    let actorIds = Object.keys(testSession.actors);
    let actor, actorTest: ActorSessionTestState, segment;

    for (let actorIdIndex = 0; actorIdIndex < actorIds.length; ++actorIdIndex) {
        actor = testSession.actors[actorIds[actorIdIndex]];
        actorTest = actor.tests[testSession.currentTestIndex];

        if (actorTest && actorTest.segments) {
            segment = actorTest.segments[testSession.currentSegmentIndex];

            if (!segment) {
                currentSegmentWasCompleted = false;
                currentSegmentPassed = false;
                break;
            } else {
                if (segment.status !== constants.segmentStatus.COMPLETED) {
                    currentSegmentWasCompleted = false;
                    currentSegmentPassed = false;
                } else {
                    if (segment.result !== constants.segmentResult.PASSED) {
                        currentSegmentPassed = false;
                    }
                }
            }
        } else {
            currentSegmentWasCompleted = false;
        }
    }

    return {
        index: testSession.currentSegmentIndex,
        result: currentSegmentPassed ?
            constants.segmentResult.PASSED :
            constants.segmentResult.PENDING,
        status: currentSegmentWasCompleted ?
            constants.segmentStatus.COMPLETED :
            constants.segmentStatus.PENDING
    };
}

/** Creates a default subtest object that has its mandatory fields populated
 * with sensible default values. */
export function newSubtest(
    currentIteration: number = 1,
    result = constants.testResult.PENDING,
    status = constants.testStatus.PENDING): SubtestContext {

    return {
        actions: [],
        currentIteration: currentIteration,
        result: result,
        status: status,
        segments: []
    }
}

/** Iterates through all the tests in the session and populates the "testCounts"
 * property of the test session object with the data collected. */
export function populateCounts(session: TestSessionInfo) {
    let total = 0;
    let completed = 0, pending = 0;
    let passed = 0, failed = 0, skipped = 0, cancelled = 0;

    for (const test of session.tests) {
        if (test.subtests && test.subtests.length) {
            // This is a data-driven test
            for (const subTest of test.subtests) {
                incrementCounts(subTest);
            }
        } else {
            // This is a regular test
            incrementCounts(test);
        }
    }

    session.testCounts = {
        cancelled, completed, failed, passed, pending, skipped, total
    };

    function incrementCounts(test: SubtestContext) {
        total++;

        if (test.status === constants.testStatus.COMPLETED) {
            completed++;
        } else {
            pending++;
        }

        if (test.result === constants.testResult.PASSED) {
            passed++;
        } else if (test.status === constants.testResult.FAILED) {
            failed++;
        } else if (test.status === constants.testResult.SKIPPED) {
            skipped++;
        } else if (test.status === constants.testResult.CANCELLED) {
            cancelled++;
        }
    }
}

/** Resets the test status and all related fields. For all test actors,
 * resets the status and result of all the test segments for the specified
 * test to "pending". */
function resetTestStatus(testSession: TestSessionInfo, testIndex: number) {
    let test = testSession.tests[testIndex];

    test.actions = [];
    test.checkpointFailed = false;
    test.currentDataRecordIndex = 0;
    test.timeStarted = null;
    test.timeCompleted = null;
    test.sharedData = {};
    test.result = constants.testResult.PENDING;
    test.status = constants.testStatus.PENDING;

    // Reset test segments for actors for the current test index
    for (let actorId of Object.keys(testSession.actors)) {
        let actor: ActorSessionState = testSession.actors[actorId];
        actor.tests[testIndex].currentSegmentIndex = -1;
        actor.tests[testIndex].timeStarted = null;
        actor.tests[testIndex].timeCompleted = null;
        for (let segment of actor.tests[testIndex].segments) {
            segment.result = constants.segmentResult.PENDING;
            segment.status = constants.segmentStatus.PENDING;
            segment.timeStarted = null;
            segment.timeCompleted = null;
        }
    }
}

export function startCleanupInterval() {
    const config = configLoader.getConfig();
    const cleanupSessionsInterval = (config.cleanupSessionsIntervalSec || 10) * 1000;
    cleanupIntervalId = setInterval(cleanupSessions, cleanupSessionsInterval);
}

export function stopCleanupInterval() {
    clearInterval(cleanupIntervalId);
}

/** Update the status of a test segment using the supplied arguments and also
 * making sure the update makes sense (e.g. can't start a segment before the
 * previous one is completed, etc.) */
export function updateActorSegmentStatus(
    testSession: TestSessionInfo,
    actorId: any,
    testIndex: number,
    segmentIndex: number,
    newStatus: string) {

    actorId = parseInt(actorId);
    let sessionActor: ActorSessionState = testSession.actors[actorId];
    var actorTest = sessionActor.tests[testIndex];

    if (!actorTest) {
        actorTest = sessionActor.tests[testIndex] = {
            currentSegmentIndex: -1,
            segments: [],
            name: testSession.tests[testIndex].name,
            path: testSession.tests[testIndex].path,
            timeCompleted: null,
            timeStarted: Date.now()
        };
    }

    var currentSegment: TestSegmentInfo = actorTest.segments[actorTest.currentSegmentIndex];

    switch (newStatus) {
        case constants.segmentStatus.STARTED:
            let now = Date.now();

            // Make sure we're not starting the same segment twice
            if (segmentIndex === actorTest.currentSegmentIndex) {
                throw new Error(util.format('Cannot start segment %s because it was already started',
                    segmentIndex));
            }

            // Make sure the current segment is complete
            if (currentSegment && (currentSegment.status !== constants.segmentStatus.COMPLETED)) {
                throw new Error(util.format('Cannot start segment %s because the current segment is not complete yet',
                    segmentIndex));
            }

            // Update session start time
            if (!testSession.timeStarted) {
                testSession.timeStarted = now;
            }

            let test = testSession.tests[testIndex];

            // Update current test start time
            if (!test.timeStarted) {
                test.timeStarted = now;
            }

            actorTest.currentSegmentIndex = segmentIndex;

            actorTest.segments[actorTest.currentSegmentIndex] = {
                index: actorTest.currentSegmentIndex,
                status: constants.segmentStatus.STARTED,
                timeStarted: Date.now(),
                timeCompleted: null,
                result: constants.segmentResult.PENDING
            }

            if (!test.segments[actorTest.currentSegmentIndex].timeStarted) {
                test.segments[actorTest.currentSegmentIndex].timeStarted = now;
            }
            break;
        case constants.segmentStatus.COMPLETED:
            // Make sure we're completing the current segment and not something else
            if (segmentIndex !== actorTest.currentSegmentIndex) {
                throw new Error(util.format('Cannot complete segment %s because it is not the current segment (segment %s). Actor: %s. Test session: %s. Test index: %s',
                    segmentIndex,
                    actorTest.currentSegmentIndex,
                    actorId,
                    testSession.id,
                    testIndex));
            }

            currentSegment.status = constants.segmentStatus.COMPLETED;
            currentSegment.timeCompleted = Date.now();
            break;
        default:
            throw new Error(util.format('Unknown segment status "%s". Valid status values are: %s',
                newStatus,
                Object.keys(constants.segmentStatus)
                    .map((k) => { return '"' + constants.segmentStatus[k] + '"'; })
                    .join(', ')));
    }
}

/** Updates the current test index and current segment index for a session based
 * on the status reported by actors for the current test segment */
export function updateSessionState(testSession: TestSessionInfo) {
    let self = this;

    const sessionInfo = computeCurrentTestSegmentInfo(testSession);

    // Check if the current segment for the current test was completed on all actors
    var currentSegmentWasCompleted = (sessionInfo.status === constants.segmentStatus.COMPLETED);
    var currentSegmentPassed = (sessionInfo.result === constants.segmentResult.PASSED);

    var currentTestDef = testSession.tests[testSession.currentTestIndex];
    var lastSegmentIndex = Math.max.apply(null, currentTestDef.segments.map(function (s) {
        return s.index;
    }));

    // Check if the last segment for the current test was completed and advance to the next test
    if (currentSegmentWasCompleted) {
        var currentTest = testSession.tests[testSession.currentTestIndex];
        var currentSegment = currentTest.segments[testSession.currentSegmentIndex];

        currentSegment.status = constants.segmentStatus.COMPLETED;
        currentSegment.result = currentSegmentPassed ? constants.segmentResult.PASSED : constants.segmentResult.FAILED;
        currentSegment.timeCompleted = Date.now();

        let reachedLastSegment = (testSession.currentSegmentIndex >= lastSegmentIndex);

        if (reachedLastSegment || !currentSegmentPassed) {
            const now = Date.now();

            if (currentTest.isDataDriven) {
                currentTest.subtests = currentTest.subtests || [];
                const subtest = Object.assign(newSubtest(), {
                    actions: currentTest.actions,
                    checkpointFailed: currentTest.checkpointFailed,
                    currentDataRecordIndex: currentTest.currentDataRecordIndex,
                    currentIteration: currentTest.currentIteration,
                    result: currentSegmentPassed && !currentTest.checkpointFailed
                        ? constants.testResult.PASSED
                        : constants.testResult.FAILED,
                    status: constants.testStatus.COMPLETED,
                    segments: currentTest.segments,
                    timeStarted: currentTest.timeStarted,
                    timeCompleted: now
                });

                currentTest.subtests[currentTest.currentDataRecordIndex] = subtest;
            }

            const reachedLastDataRecord =
                !currentTest.isDataDriven ||
                currentTest.currentDataRecordIndex >= (currentTest.dataRecordCount || 0) - 1;

            if (reachedLastDataRecord) {
                currentTest.status = constants.testStatus.COMPLETED;
                currentTest.result = currentSegmentPassed && !currentTest.checkpointFailed ?
                    constants.testResult.PASSED :
                    constants.testResult.FAILED;
                currentTest.timeCompleted = now;

                // Advance to the next test with status "pending"
                let nextTestIndex = testSession.currentTestIndex;
                while (
                    testSession.tests[nextTestIndex] &&
                    testSession.tests[nextTestIndex].status &&
                    testSession.tests[nextTestIndex].status !== constants.testStatus.PENDING &&
                    nextTestIndex <= testSession.tests.length) {

                    ++nextTestIndex;
                }
                testSession.currentTestIndex = nextTestIndex;
                testSession.currentDataRecordIndex = -1;
            } else {
                // Increase data record index for the current test
                // and reset the test status
                let nextDataRecordIndex
                    = currentTest.currentDataRecordIndex + 1;

                resetTestStatus(testSession, testSession.currentTestIndex);
                currentTest.currentDataRecordIndex = nextDataRecordIndex;
                testSession.currentDataRecordIndex = nextDataRecordIndex;
            }

            testSession.currentSegmentIndex = 0;

            let reachedLastTest = (testSession.currentTestIndex >= testSession.tests.length);

            if (reachedLastTest) {
                let allTestsPassed = testSession.tests.every(function (test) {
                    if (test.isDataDriven) {
                        return test.subtests.every(function (t2) {
                            return t2.result === constants.testResult.PASSED;
                        });
                    } else {
                        return test.result === constants.testResult.PASSED;
                    }
                });

                //TODO: 1/23 This section needs to be pulled out of this function. We don't want any DB updates in here.
                if (allTestsPassed) {
                    sessionHelper.completeSession(testSession, constants.testSessionResult.PASSED);
                } else {
                    if (testSession.currentIteration < testSession.maxIterations) {
                        incrementIteration(testSession);
                    } else {
                        sessionHelper.completeSession(testSession, constants.testSessionResult.FAILED);
                    }
                }
            }
        } else {
            ++testSession.currentSegmentIndex;
        }
    }
}
